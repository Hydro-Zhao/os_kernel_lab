kern/mm/default_pmm.c

kern/mm/pmm.c

**TODO 注释掉了kern/init/init.c中的grade_backtrace()**

# 实验记录

实验心得：“静态分析”和“动态分析”结合，善用工具，多点切入，不“死磕” 。不知道为什么kern/init/init.c中grade_backtrace()测试返回后会回到kern_init函数开始处继续运行，导致后面mm相关测试无法进行，也就不可能通过测试（我还傻乎乎地静态分析了那么久，实际上gdb调试一下很快就定位到问题了（既然ucore的测试是通过对比qemu的输出，那就实际看一下输出是什么啊））。

## 实验手册

讲解物理内存探测的部分终于解决了我很多疑惑

建立段页式管理中需要考虑的关键问题 仔细思考

系统执行中地址映射的三个阶段 解释了ucore的地址从boot到实际运行的映射变化

链接地址/虚地址/物理地址/加载地址以及 edata/end/text 的含义 值得一看

实验执行流程概述 可以对物理内存管理部分流程有明确概念

## exercise1

实验框架已经写完几乎所有的代码，我只需要按照首次适应算法的逻辑修改相关部分就行了，主要就是要在正确的位置插入缩小或扩大的空闲链表项（使得链表是按地址由低到高排列）。

## exercise2

按照代码中的注释填写代码

注意在地址转换过程中使用的是物理地址还是线性地址。页目录项和页表项中使用的是物理地址，在由页目录项得到页表地址时，要将页目录项的地址转换成线性地址。

## exercise3

要回答练习中的问题，要反复阅读 系统执行中地址映射的三个阶段 这一部分。

非常愚蠢的bug
```
right: if (!create || (page = alloc_page()) == NULL)
wrong: if (!create || (page = alloc_page() == NULL))
```

## 扩展练习 Challenge：buddy system（伙伴系统）分配算法（需要编程）

## 扩展练习 Challenge：任意大小的内存单元 slub 分配算法（需要编程）